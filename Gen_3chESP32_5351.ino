// 3 channel clock generator : VU2SPF 24th Aug 2025
// Sketch to control Si5351 , All 3 clocks can be controlled.Both freq and enabling of any channel done.
// freq change steps from 1 Hz to 1MHz -
// modified for esp32 with spi 2.8 inch display
// Original flow generated by chatgpt,which was debugged, modified and adopted as per our need.
// please pass your observations, errors and suggestions to vu2spf [at] gmail [dot] com

//standard Arduino Libs
#include <SPI.h>
#include <Wire.h>
#include <EEPROM.h>
// Special Libs
#include <TFT_eSPI.h>    // Bodmers TFT-eSPI Library https://github.com/Bodmer/TFT_eSPI
#include <si5351.h>      // Etherkit Library https://github.com/etherkit/Si5351Arduino
#include <Encoder.h>     // http://www.pjrc.com/teensy/td_libs_Encoder.html

// ---------------- TFT + Touch Config ----------------

TFT_eSPI tft = TFT_eSPI(); // create an instance of tft - Bodmers lib

//---------------tft colors ------------------
// Assign human-readable names to some common 16-bit color values:
#define BLACK       0x0000      /*   0,   0,   0 */
#define LIGHTGREY   0xC618      /* 192, 192, 192 */
#define GREY        0x7BEF      /* 128, 128, 128 */
#define BLUE        0x001F      /*   0,   0, 255 */
#define RED         0xF800      /* 255,   0,   0 */
#define YELLOW      0xFFE0      /* 255, 255,   0 */
#define WHITE       0xFFFF      /* 255, 255, 255 */
#define ORANGE      0xFD20      /* 255, 165,   0 */
#define GREEN       0x07E0
#define CYAN        0x07FF
#define MAGENTA     0xF81F
#define NAVY        0x000F      /*   0,   0, 128 */
#define DARKGREEN   0x03E0      /*   0, 128,   0 */
#define DARKCYAN    0x03EF      /*   0, 128, 128 */
#define MAROON      0x7800      /* 128,   0,   0 */
#define PURPLE      0x780F      /* 128,   0, 128 */
#define OLIVE       0x7BE0      /* 128, 128,   0 */
#define DARKGREY    0x742F      /* fGREY*/
#define GREENYELLOW 0xAFE5      /* 173, 255,  47 */
#define PINK        0xF81F
//--------------UI Colour Plan ---------------
#define BkGndColour NAVY       // General back ground colour
#define FreqColour WHITE       // colour for displaying freq - touch area to select a channel for modification
#define ClkColour YELLOW       // Clock (Ckx) on left of freq - touch area for freq decrement
#define HzColour YELLOW        // Hz on right of freq - touch area for increasing the freq
#define HighlightColour GREY   // selected channel has background of this colour 
#define GenTextColour WHITE    // Text colour - non touch
#define ButtonRectColour WHITE // For drawing rectangle around button
#define StepTextColour WHITE   // Text in step size button

// ---------------- Rotary Encoder ----------------
Encoder knob(25, 26); // If needed a rotary encoder may be connected
long lastPos = 0;
// ---------------- Si5351 ----------------
Si5351 si5351;   // create an instance for Si5351 generator IC
int32_t correction = 0; // calibration in ppb
// ---------------- Step Sizes ----------------
uint32_t stepSizes[] = {1, 10, 100, 1000, 10000, 100000, 1000000};
const int NUM_STEPS = 7;
// we use these step sizes to increment or decrement channels frequency
// ---------------- Channel State ----------------
// for each channel or clock these structures are used to save current state
struct Channel {
  bool enabled;
  uint32_t freq;
  int stepIndex;
};
// Initialize the structures for each of the 3 channels (Default values - Also set by Reset button under calib)
Channel channels[3] = {
  {true, 1000000, 3}, // 1 MHz, step = 1 kHz
  {false, 2000000, 3}, // 2 MHz
  {false, 3000000, 3} // 3 MHz
};

int selectedChannel = 0; // Initial at power on
bool inCalibration = false;
int prevSelectedChannel = 0; //used when channel selection changes
// ---------------- EEPROM ----------------
// Saved Data in EEPROM used at startup to remember previous settings
struct Settings {
  uint32_t marker; // version marker
  int32_t correction;
  Channel channels[3];
};

#define EEPROM_ADDR 0
#define SETTINGS_MARKER 0x53514731 // "SQG1"

unsigned long lastChange = 0;
bool pendingSave = false;
bool confirmReset = false;

// ---------------- Function Prototypes ----------------
void drawMainUI();
void drawChannel(int i);
void drawStepButtons();
void drawSaveButton(int i);
void drawCalButton();
void updateChannel();
void updateOnOff();
void drawCalibrationUI();
void updateSi5351();
void applyCorrection();
void handleTouch();
void handlencoder();
void saveSettings();
void loadSettings();

//------------------------------------------
void setup() {
  Serial.begin(115200); // passes some info on serial port
  tft.init();
  tft.setRotation(1);
  tft.fillScreen(BkGndColour);

  // Use this calibration code in setup(): gen by calibration prog
  //for spi display #2
  uint16_t calData[5] = { 411, 3494, 297, 3509, 7 };
  tft.setTouch(calData);

  Wire.begin();   // for si5351

  if (si5351.init(SI5351_CRYSTAL_LOAD_8PF, 0, 0) != true) {
    Serial.println("Si5351 not found!");
    //   while (1);
  }

  EEPROM.begin(1024);

  loadSettings(); // get saved settings from EEPROM
  applyCorrection();

  // Si5351 outputs activated
  for (int i = 0; i < 3; i++) {
    si5351.output_enable((si5351_clock)i, 1);
  }

  updateSi5351(); // set frequencies of all 3 channels
  drawMainUI();  // display all ch + steps + cal buttons
}   // end of setup

//-----------+++++++----------
void loop() {
  handleTouch();    // check if any button pressed
  if (!inCalibration) {
    handlencoder();  // check if encoder changed
  }
  /* This section was planned to save details of all 3 channels peiodically
     but later changed to a save button on main screen
    if (pendingSave && millis() - lastChange > 30000) {  // save after 30 sec of change
          saveSettings();   // replaced with save button
      pendingSave = false;
    } */
}  // end of loop

// ---------------- Main UI ----------------
// Create main display from where the control happens
void drawMainUI() {
  tft.fillScreen(BkGndColour);
  tft.setTextSize(3);

  drawChannel(0); // for each channel display one line
  drawChannel(1); // Active channel is highlighted
  drawChannel(2);

  drawSaveButton(0);  // 0 for initial color Green
  // Selected Step size is for currently active channel/clock
  tft.setTextSize(2);
  tft.setTextColor(GenTextColour);
  tft.setCursor(120, 155);
  tft.print("Step Hz");

  drawCalButton(); // create calibration button
  drawStepButtons(); // draw step size buttons
}  // end of drawMainUI()
//-----------------------------------------
// displays info about Channel: Clock No of 5351, Freq, Hz, On/OFF
// A currently selected channel is highlighted
// Touching around Clk# decreases frequency by the currently selected step size
// Touching around Hz increases frequency, Touching ON/OFF will toggle output

void drawChannel(int i) {    //i is ch no 0-2
  tft.setTextSize(3);
  int y = 15 + i * 45;          //y = 30, 100, 170
  if (i == selectedChannel)   // rect= (0,20)-(380,70)
    tft.fillRect(0, y - 5, 260, 32, HighlightColour); // highlighted
  else {
    tft.fillRect(0, y - 5, 260, 32, BkGndColour); // non highlighted
  }
  tft.setCursor(5, y);
  tft.setTextColor(ClkColour);
  tft.print("Ck");   // Si5351 Clock Number (0/1/2) in Yellow
  tft.print(i);

  tft.setTextColor(FreqColour); // frequency in white
  tft.setCursor(80, y);
  tft.print(channels[i].freq);
  tft.setTextColor(HzColour);  // Hz in Yellow
  if (channels[i].freq >= 10000000)
    tft.print("Hz");
  else
    tft.print(" Hz");

  tft.setCursor(265, y);
  tft.setTextColor(channels[i].enabled ? GREEN : RED);  // Fixed colours
  tft.print(channels[i].enabled ? " ON" : "OFF");

  drawStepButtons();  // to highlight currently selected step size
}  // end of drawChannel()
//---------------------------------------
void drawStepButtons()    // Step size buttons for selected channel/clock
{
  tft.setTextSize(2);
  tft.setTextColor(StepTextColour);

  int yBase = 180;  // Base y coordinate for drawing step buttons

  for (int i = 0; i < NUM_STEPS; i++) {
    int x = 5 + i * 45;   //each button width 45, ht 50 px
    int w = 43, h = 50;
    if (i == channels[selectedChannel].stepIndex) {
      tft.fillRect(x + 2, yBase + 2, w - 2, h - 2, HighlightColour); // selected size
      tft.drawRect(x, yBase, w, h, ButtonRectColour);
    } else {
      tft.fillRect(x, yBase, w, h, BkGndColour);
      tft.drawRect(x, yBase, w, h, ButtonRectColour);
    }

    if (i == 5)                   //100k spacing fom 0 posn
      tft.setCursor(x, yBase + 15);
    else
      tft.setCursor(x + 4, yBase + 15); // all others from 4th px
    tft.setTextColor(StepTextColour);

    if (stepSizes[i] < 1000) {     //display fomatting
      tft.print(stepSizes[i]);
    } else if (stepSizes[i] < 1000000) {
      tft.print(stepSizes[i] / 1000);
      tft.print("k");
    } else {
      tft.print("1M");
    }
  }
} // end of drawStepButtons
//--------------------------------------------------------
void drawSaveButton(int i) {    // to save current freq etc on EEPROM- button colour Green , changes to Yellow when saving
  tft.setTextSize(2);
  tft.setCursor(3, 150);

  if (i == 0) {  // initial cond for green button
    tft.fillRect(3, 145, 49, 30, GREEN);  // displays green normally
    tft.setTextColor(RED);
    tft.print("SAVE");
  } else {
    tft.fillRect(5, 145, 49, 30, YELLOW); // Yellow when saving
    tft.setTextColor(BLUE);
    tft.print("SAVE");
    delay(500); // it happens very fast, so some delay to confirm save, visually, there is also a message on serial port
  }
}   // end of drawSaveButton()
//--------------------------------------------------------
void drawCalButton() {   // Calibrate Si5351, due to xtal freq variation
  // CAL button
  tft.setTextSize(2);
  tft.fillRect(265, 145, 49, 30, GREEN);
  tft.setCursor(275, 150);
  tft.setTextColor(RED);
  tft.print("CAL");
}   // end of drawCalButton()
//-------------------
void updateChannel() {    // whenever there is change in freq
  tft.setTextSize(3);
  int i = prevSelectedChannel;
  drawChannel(i);
  i = selectedChannel;
  drawChannel(i);
}  // end of updateChannel
//-------------
void updateOnOff() {    // if a channel's state is toggled by touch
  tft.setTextSize(3);
  for (int i = 0; i < 3; i++) {
    int y = 15 + i * 45;
    tft.setCursor(265, y);
    tft.fillRect(265, y, 60, 36, BkGndColour);
    tft.setTextColor(channels[i].enabled ? GREEN : RED);
    tft.print(channels[i].enabled ? " ON " : "OFF");
  }
}
//--------------------------------------------------
// ---------------- Calibration UI ----------------
void drawCalibrationUI() {  // create page for Entering correction
  tft.fillScreen(BLACK);
  tft.setTextSize(2);
  tft.setTextColor(GenTextColour);

  tft.setCursor(31, 20);
  tft.print("Calibration");

  tft.setCursor(31, 60);
  tft.print("Corr: ");
  tft.print(correction);
  tft.print(" ppb");

  // Adjustment buttons
  const char* labels[] = { "-1000", "-100", "-10", "+10", "+100", "+1000" };

  for (int i = 0; i < 6; i++) { // draw 6 buttons
    int x = 5 + (i % 3) * 66;
    int y = 95 + (i / 3) * 30;
    tft.drawRect(x, y, 60, 30, ButtonRectColour);
    tft.setCursor(x + 1, y + 8);
    tft.print(labels[i]);
  }

  // BACK button to go back to main screen
  tft.fillRect(70, 180, 65, 30, RED);
  tft.setCursor(75, 190);
  tft.setTextColor(WHITE);
  tft.print("BACK");

  // RESET button to reset all 3 channels to preset values
  tft.fillRect(230, 180, 65, 30, YELLOW);
  tft.setCursor(235, 190);
  tft.setTextColor(BLACK);
  tft.print("RESET");

  if (confirmReset) {     // WHEN RESET BUTTON presed display - Set Default? message with YES and NO buttons
    tft.setTextColor(GenTextColour);     // Confirmation popup
    tft.setCursor(235, 20);
    tft.print("SET");
    tft.setCursor(210, 50);
    tft.print("DEFAULT?");

    // YES button
    tft.fillRect(230, 85, 65, 30, GREEN);
    tft.setCursor(245, 93);
    tft.setTextColor(BLACK);
    tft.print("YES");

    // NO button
    tft.fillRect(230, 130, 65, 30, RED);
    tft.setCursor(245, 138);
    tft.setTextColor(WHITE);
    tft.print("NO");
    return;
  }
} // end of drawCalibrationUI

// ---------------- SI5351 ----------------
void updateSi5351() {    // set output freq and enable channel
  for (int i = 0; i < 3; i++) {
    if (channels[i].enabled) {
      si5351.set_freq((uint64_t)channels[i].freq * SI5351_FREQ_MULT, (si5351_clock)i);
      si5351.output_enable((si5351_clock)i, 1);
    } else {
      si5351.output_enable((si5351_clock)i, 0);
    }
  }
  //  lastChange = millis(); // to be used for autosave
  //  pendingSave = true;
}  // end of updateSi5351()
//-------------------------------------------
void applyCorrection() {
  si5351.set_correction(correction, SI5351_PLL_INPUT_XO);
  lastChange = millis();
  pendingSave = true;
}  // end of applyCorrection()

// ---------------- Input Handling ----------------
void handleTouch() {    // detect touch and take action
  uint16_t x, y;

  if (!tft.getTouch(&x, &y)) // eSPI_TFT library call
    return;
  delay(100);     // to avoid multiple touches

  //  Serial.print(x); Serial.print(":"); Serial.println(y);

  if (!inCalibration) {    // in main UI screen
    // Channel select touch
    for (int i = 0; i < 3; i++) {
      int yMin = 15 + (i * 40) - 10;
      int yMax = yMin + 40 + 10;
      if (y >= yMin && y <= yMax) {
        if (x < 60 && i == selectedChannel) {         // decrease freq by step size
          int stepIdx = channels[selectedChannel].stepIndex;
          channels[selectedChannel].freq -= stepSizes[stepIdx];
          drawChannel(i); // update freq part of display
          updateSi5351();
        }
        else if (x > 65 && x < 180) {   // touch near center to select a channel
          prevSelectedChannel = selectedChannel;
          selectedChannel = i;
          updateChannel();
        }
        else if (x > 190 && x < 240 && i == selectedChannel) {  // increase freq by step size
          int stepIdx = channels[selectedChannel].stepIndex;
          channels[selectedChannel].freq += stepSizes[stepIdx];
          drawChannel(i); // update freq part of display
          updateSi5351();
        }
        else if (x > 270) {  //ON/OFF control buton touch
          channels[i].enabled = !channels[i].enabled;
          updateSi5351();
          updateOnOff();
        }
      }
    }

    // Step size buttons touched
    int yBase = 180;
    if (y >= yBase && y <= yBase + 50) {
      for (int i = 0; i < NUM_STEPS; i++) {
        int xMin = 5 + i * 45;
        int xMax = xMin + 42;
        if (x >= xMin && x <= xMax) {
          channels[selectedChannel].stepIndex = i;
          lastChange = millis();
          pendingSave = true;
          drawStepButtons(); // only redraw step buttons
        }
      }
    }
    if (x > 5 && x < 60 && y > 140 && y < 170) {
      //save button touched
      saveSettings();
    }
    // CAL button touched
    if (x > 265 && y > 140 && y < 170) {
      inCalibration = true;
      drawCalibrationUI();
    }
  }  // end loop !inCalibration
  else  // when in calibration
  {
    if (confirmReset) {
      // Handle confirmation screen, pressed Yes
      if (x > 230 && x < 295 && y > 85 && y < 110) {
        // YES button touched/pressed
        correction = 0;
        channels[0] = {true, 1000000, 3};
        channels[1] = {false, 2000000, 3};
        channels[2] = {false, 3000000, 3};
        applyCorrection();
        updateSi5351();
        confirmReset = false;
        drawCalibrationUI();
      }
      else if (x > 230 && x < 295 && y > 130 && y < 160) {
        // NO button touched/pressed
        confirmReset = false;
        drawCalibrationUI();
      }
    }
    else
      // BACK button touched
      if (x > 70 && x < 135 && y > 180 && y < 210) {
        inCalibration = false;
        updateSi5351();
        drawMainUI();
      }

    // RESET button touched
      else if (x > 230 && x < 295 && y > 180) {
        confirmReset = true;
        drawCalibrationUI();
      }
    // Calibration mode - find correction fron place touched
      else if (y > 75 && y < 125) {
        if (x < 66) correction -= 1000;
        else if (x < 130) correction -= 100;
        else if (x < 190) correction -= 10;
        applyCorrection();
        drawCalibrationUI();
      }
      else if (y > 125 && y < 160) {
        if (x < 66) correction += 10;
        else if (x < 130) correction += 100;
        else if (x < 190) correction += 1000;
        applyCorrection();
        drawCalibrationUI();
      }
  }
}      // end of handleTouch()
//----------------------------------------------------------
void handlencoder() {     // when using encoder
  long pos = knob.read() / 2;     // or /4
  if (pos != lastPos) {
    long delta = pos - lastPos;
    int stepIdx = channels[selectedChannel].stepIndex;
    channels[selectedChannel].freq += delta * stepSizes[stepIdx];

    if (channels[selectedChannel].freq < 8) channels[selectedChannel].freq = 8;
    if (channels[selectedChannel].freq > 160000000) channels[selectedChannel].freq = 160000000;

    updateSi5351();
    lastPos = pos;
    updateChannel();
  }
}

// ---------------- EEPROM ----------------
void saveSettings() {
  Settings s;
  s.marker = SETTINGS_MARKER;
  s.correction = correction;
  for (int i = 0; i < 3; i++) {
    s.channels[i] = channels[i];
  }
  drawSaveButton(1);   // yellow button when saving
  EEPROM.put(EEPROM_ADDR, s);
  EEPROM.commit();                          // for ESP32 which uses part of flash mem as EEPROM
  Serial.println("Settings saved to EEPROM");
  drawSaveButton(0);  //Green button normal
}

void loadSettings() {
  Settings s;
  EEPROM.get(EEPROM_ADDR, s);
  if (s.marker == SETTINGS_MARKER) {
    correction = s.correction;
    for (int i = 0; i < 3; i++) {
      channels[i] = s.channels[i];
    }
    Serial.println("Settings loaded from EEPROM");
  } else {
    Serial.println("EEPROM empty, using defaults");
  }
}
